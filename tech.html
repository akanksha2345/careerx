<!DOCTYPE html>
<html>
    <head>
        <title>tech documentation

        </title>
        <style>
            *{
                margin:0;
                padding: 0;

            }
            body{ 
                background-color: #490B3D;

            }
            .main{
                width:100%;
                height:100vh;
                
                
            }
            center{
                text-align: center;
                text-transform: uppercase;
                font-size: 100px;
                color:#F1B814;
            }
            #left{
                margin-left:2%;
                margin-top: 1%;
                margin-bottom: 5%;
                margin-right: 2%;
                position: absolute;
                width:300px;
                height: 700px;
                border:5px;
                border-style: solid;
                border-color: #490B3D;
                background-color:#F1B814;

            }
            #right{
                background-color:#F1B814;
                margin-left:25% ;
                margin-top: 1%;
                margin-bottom: 5%;
                margin-right: 2%;
                width:auto;
                position:inherit;
                height:auto;
                border:5px;
                border-style: solid;
                border-color:#490B3D ; 
             }
             p{
                font-size: 30px;
                color:white;
                margin-top: 2%;
                margin-left: 2%;
                margin-top: 2%;
                
                margin-right: 2%;
                margin-bottom: 2%;
                padding: 5px;
                text-transform: capitalize;
             }
             button{
                margin:2%;
                font-family: "Roboto", sans-serif;
                text-transform: uppercase;
                 outline: 0;
                background-color:white;
                width: 80%;
               border-radius: 10px;
               box-shadow: #08ac4b;
               border-color: white;
               padding: 10px;
              color: #BD1E51;
              font-size: 20px;
              font-weight: 600;
             -webkit-transition: all 0.3 ease;
             transition: all 0.3 ease;
             cursor: pointer;

             }
             span{
                text-align: left;
                justify-content: flex-end;
                font-size: medium;
                text-transform:capitalize ;
                font-weight: 900;
                font-style: italic;
                margin:1%;
                padding: 5px;
                display: flex;
                color:wheat;
                

             }
           

        </style>

    </head>
    <body>
        <div id="main"><center>c programming language</center>
            <div id="left">
              <p>documentation menu</p>
              <button>what is c</button>  
              <button>overview</button>   
              <button>histroy</button>   
              <button>basics</button>   
              <button>all</button>    
            </div>



            <div id="right"><br>
                
            <span>
                
                
                what is c?
                <br><br>
                C (pronounced like the letter c)[6] is a general-purpose computer programming language. It was created in the 1970s by Dennis Ritchie, and remains very widely used and influential. By design, C's features cleanly reflect the capabilities of the targeted CPUs. It has found lasting use in operating systems, device drivers, protocol stacks, though decreasingly[7] for application software. C is commonly used on computer architectures that range from the largest supercomputers to the smallest microcontrollers and embedded systems.

                A successor to the programming language B, C was originally developed at Bell Labs by Ritchie between 1972 and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix operating system.[8] During the 1980s, C gradually gained popularity. It has become one of the most widely used programming languages,[9][10] with C compilers available for practically all modern computer architectures and operating systems. C has been standardized by ANSI since 1989 (ANSI C) and by the International Organization for Standardization (ISO).
                
                C is an imperative procedural language, supporting structured programming, lexical variable scope and recursion, with a static type system. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support. Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A standards-compliant C program written with portability in mind can be compiled for a wide variety of computer platforms and operating systems with few changes to its source code.[11]
                
                Since 2000, C has consistently ranked among the top two languages in the TIOBE index, a measure of the popularity of programming languages.[1
                C is a general-purpose programming language created by Dennis Ritchie at the Bell Laboratories in 1972. 
        It is a very popular language, despite being old. C is strongly associated with UNIX, as it was developed to write the UNIX oper
        ating system.<br>
        <br>


        overview<br>
        <br>
        C is an imperative, procedural language in the ALGOL tradition. It has a static type system. In C, all executable code is contained within subroutines (also called "functions", though not in the sense of functional programming). Function parameters are passed by value, although arrays are passed as pointers, i.e. the address of the first item in the array. Pass-by-reference is simulated in C by explicitly passing pointers to the thing being referenced.

C program source text is free-format, using the semicolon as a statement separator and curly braces for grouping blocks of statements.

The C language also exhibits the following characteristics:

The language has a small, fixed number of keywords, including a full set of control flow primitives: if/else, for, do/while, while, and switch. User-defined names are not distinguished from keywords by any kind of sigil.
It has a large number of arithmetic, bitwise, and logic operators: +,+=,++,&,||, etc.
More than one assignment may be performed in a single statement.
Functions:
Function return values can be ignored, when not needed.
Function and data pointers permit ad hoc run-time polymorphism.
Functions may not be defined within the lexical scope of other functions.
Variables may be defined within a function, with scope.
A function may call itself, so recursion is supported.
Data typing is static, but weakly enforced; all data has a type, but implicit conversions are possible.
User-defined (typedef) and compound types are possible.
Heterogeneous aggregate data types (struct) allow related data elements to be accessed and assigned as a unit.
Union is a structure with overlapping members; only the last member stored is valid.
Array indexing is a secondary notation, defined in terms of pointer arithmetic. Unlike structs, arrays are not first-class objects: they cannot be assigned or compared using single built-in operators. There is no "array" keyword in use or definition; instead, square brackets indicate arrays syntactically, for example month[11].
Enumerated types are possible with the enum keyword. They are freely interconvertible with integers.
Strings are not a distinct data type, but are conventionally implemented as null-terminated character arrays.
Low-level access to computer memory is possible by converting machine addresses to pointers.
Procedures (subroutines not returning values) are a special case of function, with an untyped return type void.
Memory can be allocated to a program with calls to library routines.
A preprocessor performs macro definition, source code file inclusion, and conditional compilation.
There is a basic form of modularity: files can be compiled separately and linked together, with control over which functions and data objects are visible to other files via static and extern attributes.
Complex functionality such as I/O, string manipulation, and mathematical functions are consistently delegated to library routines.
The generated code after compilation has relatively straightforward needs on the underlying platform, which makes it suitable for creating operating systems and for use in embedded systems.
While C does not include certain features found in other languages (such as object orientation and garbage collection), these can be implemented or emulated, often through the use of external libraries (e.g., the GLib Object System or the Boehm garbage collector).

Relations to other languages
Many later languages have borrowed directly or indirectly from C, including C++, C#, Unix's C shell, D, Go, Java, JavaScript (including transpilers), Julia, Limbo, LPC, Objective-C, Perl, PHP, Python, Ruby, Rust, Swift, Verilog and SystemVerilog (hardware description languages).[5] These languages have drawn many of their control structures and other basic features from C. Most of them (Python being a dramatic exception) also express highly similar syntax to C, and they tend to combine the
 recognizable expression and statement syntax of C with underlying type systems, data models, and semantics that can be radically different.
 <br>
 <br>
 histroy
 <br>
 <br>
 Early developments
Timeline of C language
Year	Informal name[11]	C Standard
1972	Birth	
1978	K&R C	
1989/1990	ANSI C, ISO C	ISO/IEC 9899:1990
1999	C99	ISO/IEC 9899:1999
2011	C11, C1x	ISO/IEC 9899:2011
2018	C17	ISO/IEC 9899:2018
2023*	C23, C2x	
The origin of C is closely tied to the development of the Unix operating system, originally implemented in assembly language on a PDP-7 by Dennis Ritchie and Ken Thompson, incorporating several ideas from colleagues. Eventually, they decided to port the operating system to a PDP-11. The original PDP-11 version of Unix was also developed in assembly language.[8]

B
Main article: B (programming language)
Thompson desired a programming language to make utilities for the new platform. At first, he tried to make a Fortran compiler, but soon gave up the idea. Instead, he created a cut-down version of the recently developed BCPL systems programming language. The official description of BCPL was not available at the time,[13] and Thompson modified the syntax to be less wordy, and similar to a simplified ALGOL known as SMALGOL.[14] The result was what Thompson called B.[8] He described B as "BCPL semantics with a lot of SMALGOL syntax".[14] Like BCPL, B had a bootstrapping compiler to facilitate porting to new machines.[14] However, few utilities were ultimately written in B because it was too slow, and could not take advantage of PDP-11 features such as byte addressability.

New B and first C release
In 1971, Ritchie started to improve B, to utilise the features of the more-powerful PDP-11. A significant addition was a character type. He called this New B.[14] Thompson started to use NB to write the Unix kernel, and his requirements shaped the direction of the language development.[14][15] Through to 1972, richer types were added to the NB language: NB had arrays of int and char. Pointers, the ability to generate pointers to other types, arrays of all types, and types to be returned from functions were all also added. Arrays within expressions became pointers. A new compiler was written, and the language was renamed C.[8]

The C compiler and some utilities made with it were included in Version 2 Unix, which is also known as Research Unix.[16]

Structures and the Unix kernel re-write
At Version 4 Unix, released in November 1973, the Unix kernel was extensively re-implemented in C.[8] By this time, the C language had acquired some powerful features such as struct types.

The preprocessor was introduced around 1973 at the urging of Alan Snyder and also in recognition of the usefulness of the file-inclusion mechanisms available in BCPL and PL/I. Its original version provided only included files and simple string replacements: #include and #define of parameterless macros. Soon after that, it was extended, mostly by Mike Lesk and then by John Reiser, to incorporate macros with arguments and conditional compilation.[8]

Unix was one of the first operating system kernels implemented in a language other than assembly. Earlier instances include the Multics system (which was written in PL/I) and Master Control Program (MCP) for the Burroughs B5000 (which was written in ALGOL) in 1961. In around 1977, Ritchie and Stephen C. Johnson made further changes to the language to facilitate portability of the Unix operating system. Johnson's Portable C Compiler served as the basis for several implementations of C on new platforms.[15]

K&R C

The cover of the book The C Programming Language, first edition, by Brian Kernighan and Dennis Ritchie
In 1978, Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language.[17] This book, known to C programmers as K&R, served for many years as an informal specification of the language. The version of C that it describes is commonly referred to as "K&R C". As this was released in 1978, it is also referred to as C78.[18] The second edition of the book[19] covers the later ANSI C standard, described below.

K&R introduced several language features:

Standard I/O library
long int data type
unsigned int data type
Compound assignment operators of the form =op (such as =-) were changed to the form op= (that is, -=) to remove the semantic ambiguity created by constructs such as i=-10, which had been interpreted as i =- 10 (decrement i by 10) instead of the possibly intended i = -10 (let i be −10).
Even after the publication of the 1989 ANSI standard, for many years K&R C was still considered the "lowest common denominator" to which C programmers restricted themselves when maximum portability was desired, since many older compilers were still in use, and because carefully written K&R C code can be legal Standard C as well.

In early versions of C, only functions that return types other than int must be declared if used before the function definition; functions used without prior declaration were presumed to return type int.
<br>
<br>


BASICS
 <br>
 <br>

supports the use of pointers, a type of reference that records the address or location of an object or function in memory.
 Pointers can be dereferenced to access data stored at the address pointed to, or to invoke a pointed-to function.
  Pointers can be manipulated using assignment or pointer arithmetic. The run-time representation of a pointer value is typically a raw memory address (perhaps augmented by an offset-within-word field), but since a pointer's type includes the type of the thing pointed to, expressions including pointers can be type-checked at compile time. Pointer arithmetic is automatically scaled by the size of the pointed-to data type.

Pointers are used for many purposes in C. Text strings are commonly manipulated using pointers into arrays of characters.
 Dynamic memory allocation is performed using pointers; the result of a malloc is usually cast to the data type of the data to be stored. Many data types, such as trees, are commonly implemented as dynamically allocated struct objects linked together using pointers. Pointers to other pointers are often used in multi-dimensional arrays and arrays of struct objects. Pointers to functions (function pointers) are useful for passing functions as arguments to higher-order functions (such as qsort or bsearch), in dispatch tables, or as callbacks to event handlers .[34]

A null pointer value explicitly points to no valid location. Dereferencing a null pointer value is undefined,
 often resulting in a segmentation fault. Null pointer values are useful for indicating special cases such as no "next" pointer in the final node of a linked list, or as an error indication from functions returning pointers. In appropriate contexts in source code, such as for assigning to a pointer variable, a null pointer constant can be written as 0, with or without explicit casting to a pointer type, or as the NULL macro defined by several standard headers. In conditional contexts, null pointer values evaluate to false, while all other pointer values evaluate to true.

Void pointers (void *) point to objects of unspecified type, and can therefore be used as "generic" data pointers. Since the size and type of the pointed-to object is not known, void pointers cannot be dereferenced, nor is pointer arithmetic on them allowed, although they can easily be (and in many contexts implicitly are) converted to and from any other object pointer type.[34]

Careless use of pointers is potentially dangerous. Because they are typically unchecked, a pointer variable can be made to point to any arbitrary location, which can cause undesirable effects. Although properly used pointers point to safe places, they can be made to point to unsafe places by using invalid pointer arithmetic; the objects they point to may continue to be used after deallocation (dangling pointers); they may be used without having been initialized (wild pointers); or they may be directly assigned an unsafe value using a cast, union, or through another corrupt pointer. In general, C is permissive in allowing manipulation of and conversion between pointer types, although compilers typically provide 
options for various levels of checking. Some other programming languages address these problems by using more restrictive reference types.<br>

            </span>
        </div>
        </div>
    </body>
</html>